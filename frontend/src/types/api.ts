/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/professiondefoi/{id}": {
    /**
     * @description Returns the corresponding "ArchiveElectoralProfessionDeFoi" object.
     * It's just a do a GET /archiveselectoralesducevipof/id on ElasticSearch and returns the underlying source object.
     */
    get: operations["Proxy"];
  };
  "/professiondefoi/search": {
    /**
     * @description This is a proxy method to ElasticSearch "search" on the index 'archiveselectoralesducevipof'.
     * The body will be passed to elasticsearch.
     * Example : {
     *   "query": {
     *     "simple_query_string": {
     *       "fields": [ "title" ],
     *       "query": "*"
     *     }
     *   }
     * }
     */
    post: operations["Search"];
  };
  "/professiondefoi/search/csv": {
    /**
     * @description Given an ES search query, this method will create a CSV file in a stream way of the entire result.
     * Example : {
     *   "query": {
     *     "simple_query_string": {
     *       "fields": [ "title" ],
     *       "query": "*"
     *     }
     *   }
     * }
     */
    post: operations["SearchAsCsv"];
  };
  "/elasticsearch/proxy_search": {
    /**
     * @description This is a proxy method to ElasticSearch "search" on the index 'archiveselectoralesducevipof' per default, but you can specify it.
     * The body will be passed to elasticsearch.
     */
    post: operations["Proxy"];
  };
  "/import": {
    /**
     * @description Execute the import.
     *
     * Errors don't block the import process. So the process should never fails,
     * instead it returns the list of errors that the processus has encountered.
     * If you have errors, you should have the list of IDS in the report, and you can retry to import those items
     * by calling this method.
     *
     * NOTE: To trigger a full reindex, just delete the file <code>last_import_date_file_path</code> on the FS
     *
     * IMPORTANT: You can override the period & index name of the import, by specifying the paramater <code>options</code>
     * on this method. It can be usefull to make an import per party (ex: by week slices).
     */
    post: operations["Import"];
  };
  "/misc/ping": {
    /** @description Just a ping endpoint that respond "pong" to see if the service is alive. */
    get: operations["Ping"];
  };
  "/misc/echo": {
    /**
     * @description This echo endpoint respond to you what you give it.
     * It can be usefull to see if the service is alive.
     */
    post: operations["Echo"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    ArchiveElectoralCandidat: {
      nom: string;
      prenom: string;
      type: string;
      sexe: string;
      age?: string;
      "age-calcule"?: string;
      "age-tranche"?: string;
      profession: string[];
      "mandat-en-cours": string[];
      "mandat-passe": string[];
      associations: string[];
      "autres-statuts": string[];
      soutien: string[];
      liste: string[];
      decorations: string;
      [key: string]: unknown;
    };
    ArchiveElectoralProfessionDeFoi: {
      id: string;
      candidats: components["schemas"]["ArchiveElectoralCandidat"][];
      /** Format: date-time */
      date: string;
      annee: string;
      subject: string[];
      title: string;
      type: string;
      "contexte-election": Partial<string> & Partial<string[]>;
      "contexte-tour": string;
      cote: string;
      departement: string;
      "departement-insee": string;
      "departement-nom": string;
      /** Format: double */
      "departement-order"?: number;
      circonscription: string;
      images: {
          thumb?: string;
          url: string;
        }[];
      pdf: string;
      ocr_url: string;
      [key: string]: unknown;
    };
    SearchResponse_ArchiveElectoralProfessionDeFoi_: {
      hits: {
        hits: {
            _source: components["schemas"]["ArchiveElectoralProfessionDeFoi"];
            /** Format: double */
            _score: number;
            _id: string;
            _type: string;
            _index: string;
          }[];
        /** Format: double */
        max_score: number;
        total: {
          relation: string;
          /** Format: double */
          value: number;
        };
      };
      _scroll_id?: string;
    };
    /** @description Construct a type with a set of properties K of type T */
    "Record_string.unknown_": Record<string, never>;
    SearchResponse_unknown_: {
      hits: {
        hits: {
            _source: unknown;
            /** Format: double */
            _score: number;
            _id: string;
            _type: string;
            _index: string;
          }[];
        /** Format: double */
        max_score: number;
        total: {
          relation: string;
          /** Format: double */
          value: number;
        };
      };
      _scroll_id?: string;
    };
    /** @description Error object for import report. */
    ReportError: {
      name: string;
      message: string;
      items: string[];
      [key: string]: unknown;
    };
    /** @description Import report */
    ImportReport: {
      /**
       * Format: double
       * @description Duration (in ms) of the import.
       */
      took: number;
      /**
       * Format: double
       * @description Number of item imported
       */
      total: number;
      /** @description List of errors */
      errors: components["schemas"]["ReportError"][];
      /** @description Settings used for the import */
      settings: {
        index: string;
        /** Format: date-time */
        to?: string;
        /** Format: date-time */
        from?: string;
      };
      [key: string]: unknown;
    };
    /** @description Options for the import execution. */
    ImportOptions: {
      /**
       * Format: date-time
       * @description (optional if ids is defined) The date from which we need to retrieve the last modified item
       */
      date?: string;
      /**
       * Format: date-time
       * @description (optional) The date to which we need to retrieve the last modified item
       */
      to?: string;
      /** @description (optional) The name of the ES index */
      index?: string;
      /** @description (optional) A list of ids to import */
      ids?: string[];
      [key: string]: unknown;
    };
  };
  responses: {
  };
  parameters: {
  };
  requestBodies: {
  };
  headers: {
  };
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * @description This is a proxy method to ElasticSearch "search" on the index 'archiveselectoralesducevipof' per default, but you can specify it.
   * The body will be passed to elasticsearch.
   */
  Proxy: {
    parameters: {
      query?: {
        index?: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Record_string.unknown_"];
      };
    };
    responses: {
      /** @description Ok */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponse_unknown_"];
        };
      };
      /** @description Internal Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * @description This is a proxy method to ElasticSearch "search" on the index 'archiveselectoralesducevipof'.
   * The body will be passed to elasticsearch.
   * Example : {
   *   "query": {
   *     "simple_query_string": {
   *       "fields": [ "title" ],
   *       "query": "*"
   *     }
   *   }
   * }
   */
  Search: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["Record_string.unknown_"];
      };
    };
    responses: {
      /** @description Ok */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponse_ArchiveElectoralProfessionDeFoi_"];
        };
      };
      /** @description Internal Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * @description Given an ES search query, this method will create a CSV file in a stream way of the entire result.
   * Example : {
   *   "query": {
   *     "simple_query_string": {
   *       "fields": [ "title" ],
   *       "query": "*"
   *     }
   *   }
   * }
   */
  SearchAsCsv: {
    parameters: {
      query: {
        filename: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Record_string.unknown_"];
      };
    };
    responses: {
      /** @description Ok */
      200: {
        content: {
          "application/json": string;
        };
      };
      /** @description Internal Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * @description Execute the import.
   *
   * Errors don't block the import process. So the process should never fails,
   * instead it returns the list of errors that the processus has encountered.
   * If you have errors, you should have the list of IDS in the report, and you can retry to import those items
   * by calling this method.
   *
   * NOTE: To trigger a full reindex, just delete the file <code>last_import_date_file_path</code> on the FS
   *
   * IMPORTANT: You can override the period & index name of the import, by specifying the paramater <code>options</code>
   * on this method. It can be usefull to make an import per party (ex: by week slices).
   */
  Import: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ImportOptions"];
      };
    };
    responses: {
      /** @description Ok */
      200: {
        content: {
          "application/json": components["schemas"]["ImportReport"];
        };
      };
      /** @description Partial import */
      206: {
        content: never;
      };
      /** @description Internal Error */
      500: {
        content: never;
      };
    };
  };
  /** @description Just a ping endpoint that respond "pong" to see if the service is alive. */
  Ping: {
    responses: {
      /** @description Ok */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /**
   * @description This echo endpoint respond to you what you give it.
   * It can be usefull to see if the service is alive.
   */
  Echo: {
    requestBody: {
      content: {
        "application/json": unknown;
      };
    };
    responses: {
      /** @description Ok */
      200: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
}
