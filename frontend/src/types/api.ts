/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/professiondefoi/{id}": {
    /**
     * Returns the corresponding "ArchiveElectoralProfessionDeFoi" object.
     * It's just a do a GET /archiveselectoralesducevipof/id on ElasticSearch and returns the underlying source object.
     */
    get: operations["Proxy"];
  };
  "/professiondefoi/search": {
    /**
     * This is a proxy method to ElasticSearch "search" on the index 'archiveselectoralesducevipof'.
     * The body will be passed to elasticsearch.
     * Example : {
     *   "query": {
     *     "simple_query_string": {
     *       "fields": [ "title" ],
     *       "query": "*"
     *     }
     *   }
     * }
     */
    post: operations["Search"];
  };
  "/professiondefoi/search/csv": {
    /**
     * Given an ES search query, this method will create a CSV file in a stream way of the entire result.
     * Example : {
     *   "query": {
     *     "simple_query_string": {
     *       "fields": [ "title" ],
     *       "query": "*"
     *     }
     *   }
     * }
     */
    post: operations["SearchAsCsv"];
  };
  "/elasticsearch/proxy_search": {
    /**
     * This is a proxy method to ElasticSearch "search" on the index 'archiveselectoralesducevipof' per default, but you can specify it.
     * The body will be passed to elasticsearch.
     */
    post: operations["Proxy"];
  };
  "/import": {
    /**
     * Execute the import.
     *
     * Errors don't block the import process. So the process should never fails,
     * instead it returns the list of errors that the processus has encountered.
     * If you have errors, you should have the list of IDS in the report, and you can retry to import those items
     * by calling this method.
     *
     * NOTE: To trigger a full reindex, just delete the file <code>last_import_date_file_path</code> on the FS
     *
     * IMPORTANT: You can override the period & index name of the import, by specifying the paramater <code>options</code>
     * on this method. It can be usefull to make an import per party (ex: by week slices).
     */
    post: operations["Import"];
  };
  "/misc/ping": {
    /** Just a ping endpoint that respond "pong" to see if the service is alive. */
    get: operations["Ping"];
  };
  "/misc/echo": {
    /**
     * This echo endpoint respond to you what you give it.
     * It can be usefull to see if the service is alive.
     */
    post: operations["Echo"];
  };
}

export interface components {
  schemas: {
    ArchiveElectoralCandidat: {
      nom: string;
      prenom: string;
      type: string;
      sexe: string;
      age?: string;
      "age-calcule"?: string;
      "age-tranche"?: string;
      profession: string[];
      "mandat-en-cours": string[];
      "mandat-passe": string[];
      associations: string[];
      "autres-statuts": string[];
      soutien: string[];
      liste: string[];
      decorations: string;
    } & { [key: string]: any };
    ArchiveElectoralProfessionDeFoi: {
      id: string;
      candidats: components["schemas"]["ArchiveElectoralCandidat"][];
      date: string;
      annee: string;
      subject: string[];
      title: string;
      type: string;
      "contexte-election": Partial<string> & Partial<string[]>;
      "contexte-tour": string;
      cote: string;
      departement: string;
      "departement-insee": string;
      "departement-nom": string;
      circonscription: string;
      images: {
        thumb?: string;
        url: string;
      }[];
      pdf: string;
      ocr_url: string;
    } & { [key: string]: any };
    SearchResponse_ArchiveElectoralProfessionDeFoi_: {
      hits: {
        hits: {
          _source: components["schemas"]["ArchiveElectoralProfessionDeFoi"];
          _score: number;
          _id: string;
          _type: string;
          _index: string;
        }[];
        max_score: number;
        total: {
          relation: string;
          value: number;
        };
      };
      _scroll_id?: string;
    };
    SearchResponse_any_: {
      hits: {
        hits: {
          _source: { [key: string]: any };
          _score: number;
          _id: string;
          _type: string;
          _index: string;
        }[];
        max_score: number;
        total: {
          relation: string;
          value: number;
        };
      };
      _scroll_id?: string;
    };
    /** Error object for import report. */
    ReportError: {
      name: string;
      message: string;
      items: string[];
    } & { [key: string]: any };
    /** Import report */
    ImportReport: {
      /** Duration (in ms) of the import. */
      took: number;
      /** Number of item imported */
      total: number;
      /** List of errors */
      errors: components["schemas"]["ReportError"][];
      /** Settings used for the import */
      settings: {
        index: string;
        to: string;
        from: string;
      };
    } & { [key: string]: any };
    /** Options for the import execution. */
    ImportOptions: {
      /** (optional if ids is defined) The date from which we need to retrieve the last modified item */
      date?: string;
      /** (optional) The date to which we need to retrieve the last modified item */
      to?: string;
      /** (optional) The name of the ES index */
      index?: string;
      /** (optional) A list of ids to import */
      ids?: string[];
    } & { [key: string]: any };
  };
  responses: {};
  parameters: {};
  requestBodies: {};
  headers: {};
}

export interface operations {
  /**
   * This is a proxy method to ElasticSearch "search" on the index 'archiveselectoralesducevipof' per default, but you can specify it.
   * The body will be passed to elasticsearch.
   */
  Proxy: {
    parameters: {
      query: {
        index?: string;
      };
    };
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponse_any_"];
        };
      };
      /** Internal Error */
      500: unknown;
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: any };
      };
    };
  };
  /**
   * This is a proxy method to ElasticSearch "search" on the index 'archiveselectoralesducevipof'.
   * The body will be passed to elasticsearch.
   * Example : {
   *   "query": {
   *     "simple_query_string": {
   *       "fields": [ "title" ],
   *       "query": "*"
   *     }
   *   }
   * }
   */
  Search: {
    parameters: {};
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponse_ArchiveElectoralProfessionDeFoi_"];
        };
      };
      /** Internal Error */
      500: unknown;
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: any };
      };
    };
  };
  /**
   * Given an ES search query, this method will create a CSV file in a stream way of the entire result.
   * Example : {
   *   "query": {
   *     "simple_query_string": {
   *       "fields": [ "title" ],
   *       "query": "*"
   *     }
   *   }
   * }
   */
  SearchAsCsv: {
    parameters: {
      query: {
        filename: string;
      };
    };
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": string;
        };
      };
      /** Internal Error */
      500: unknown;
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: any };
      };
    };
  };
  /**
   * Execute the import.
   *
   * Errors don't block the import process. So the process should never fails,
   * instead it returns the list of errors that the processus has encountered.
   * If you have errors, you should have the list of IDS in the report, and you can retry to import those items
   * by calling this method.
   *
   * NOTE: To trigger a full reindex, just delete the file <code>last_import_date_file_path</code> on the FS
   *
   * IMPORTANT: You can override the period & index name of the import, by specifying the paramater <code>options</code>
   * on this method. It can be usefull to make an import per party (ex: by week slices).
   */
  Import: {
    parameters: {};
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["ImportReport"];
        };
      };
      /** Partial import */
      206: unknown;
      /** Internal Error */
      500: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ImportOptions"];
      };
    };
  };
  /** Just a ping endpoint that respond "pong" to see if the service is alive. */
  Ping: {
    parameters: {};
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /**
   * This echo endpoint respond to you what you give it.
   * It can be usefull to see if the service is alive.
   */
  Echo: {
    parameters: {};
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": { [key: string]: any };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: any };
      };
    };
  };
}
